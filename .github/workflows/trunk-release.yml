name: Trunk-Based Release Pipeline

on:
  # Temporarily disabled to stop auto-creating tags while debugging
  # push:
  #   branches: 
  #     - main
  #     - 'hotfix/**'
  workflow_dispatch:
    inputs:
      promote_rc_to_release:
        description: 'RC tag to promote to release (e.g., v1.2.0-rc1)'
        required: true
        type: string

permissions:
  contents: write
  packages: write

jobs:
  # Runs on main branch pushes (squash merges) 
  create-rc:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    name: Create RC from Main Push
    runs-on: ubuntu-latest
    outputs:
      rc_tag: ${{ steps.version.outputs.rc_tag }}
      should_create_rc: ${{ steps.conventional.outputs.should_release }}
      new_version: ${{ steps.version.outputs.new_version }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze conventional commit
        id: conventional
        run: |
          # Get commit subject (first line only) for conventional commit analysis
          COMMIT_SUBJECT="$(git log -1 --pretty=%s)"
          COMMIT_BODY="$(git log -1 --pretty=%B)"
          
          echo "commit_subject=$COMMIT_SUBJECT" >> $GITHUB_OUTPUT
          
          # Use heredoc for multiline commit message
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Check if this is a conventional commit that should trigger release
          SHOULD_RELEASE="false"
          BUMP_TYPE=""
          
          # Check for breaking changes
          if [[ "$COMMIT_SUBJECT" =~ ^feat! ]] || [[ "$COMMIT_SUBJECT" =~ ^fix! ]] || [[ "$COMMIT_SUBJECT" =~ ^perf! ]] || [[ "$COMMIT_BODY" == *"BREAKING CHANGE"* ]]; then
            SHOULD_RELEASE="true"
            BUMP_TYPE="major"
          # Check for new features
          elif [[ "$COMMIT_SUBJECT" =~ ^feat: ]] || [[ "$COMMIT_SUBJECT" =~ ^feat\( ]]; then
            SHOULD_RELEASE="true"
            BUMP_TYPE="minor"
          # Check for fixes and performance improvements
          elif [[ "$COMMIT_SUBJECT" =~ ^fix: ]] || [[ "$COMMIT_SUBJECT" =~ ^fix\( ]] || [[ "$COMMIT_SUBJECT" =~ ^perf: ]] || [[ "$COMMIT_SUBJECT" =~ ^perf\( ]]; then
            SHOULD_RELEASE="true"
            BUMP_TYPE="patch"
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          if [ "$SHOULD_RELEASE" = "true" ]; then
            echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
            echo "‚úÖ Conventional commit detected: $COMMIT_SUBJECT (bump: $BUMP_TYPE)"
          else
            echo "‚ÑπÔ∏è Commit does not follow conventional commit format for releases: $COMMIT_SUBJECT"
          fi

      - name: Calculate next version
        if: steps.conventional.outputs.should_release == 'true'
        id: version
        run: |
          # Get latest release tag (not RC tags) - this is our baseline
          LATEST_RELEASE=$(git tag -l "v*" | grep -v "rc" | sort -V | tail -1)
          if [ -z "$LATEST_RELEASE" ]; then
            LATEST_RELEASE="v0.0.0"
          fi
          echo "latest_release=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          
          # Get all commits since the latest release to determine target version
          if [ "$LATEST_RELEASE" = "v0.0.0" ]; then
            # No releases yet, analyze all commits
            COMMITS_SINCE_RELEASE=$(git log --pretty=format:"%s" HEAD)
          else
            # Get commits since the last release
            COMMITS_SINCE_RELEASE=$(git log --pretty=format:"%s" ${LATEST_RELEASE}..HEAD)
          fi
          
          # Analyze all commits since last release to find highest bump type needed
          HIGHEST_BUMP="none"
          while IFS= read -r commit_msg; do
            if [[ "$commit_msg" =~ ^feat! ]] || [[ "$commit_msg" =~ ^fix! ]] || [[ "$commit_msg" =~ ^perf! ]] || [[ "$commit_msg" == *"BREAKING CHANGE"* ]]; then
              HIGHEST_BUMP="major"
              break  # Major is highest, no need to continue
            elif [[ "$commit_msg" =~ ^feat: ]] || [[ "$commit_msg" =~ ^feat\( ]]; then
              if [ "$HIGHEST_BUMP" != "major" ]; then
                HIGHEST_BUMP="minor"
              fi
            elif [[ "$commit_msg" =~ ^fix: ]] || [[ "$commit_msg" =~ ^fix\( ]] || [[ "$commit_msg" =~ ^perf: ]] || [[ "$commit_msg" =~ ^perf\( ]]; then
              if [ "$HIGHEST_BUMP" = "none" ]; then
                HIGHEST_BUMP="patch"
              fi
            fi
          done <<< "$COMMITS_SINCE_RELEASE"
          
          # Parse baseline version numbers
          BASE_VERSION=${LATEST_RELEASE#v}
          IFS='.' read -r -a VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Calculate target version based on highest bump type needed
          case "$HIGHEST_BUMP" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
            none) 
              echo "‚ö†Ô∏è No version bump needed - commits don't follow conventional format for releases"
              exit 0
              ;;
          esac
          
          TARGET_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Find next RC number for this target version
          EXISTING_RCS=$(git tag -l "v${TARGET_VERSION}-rc*" | sort -V)
          if [ -z "$EXISTING_RCS" ]; then
            RC_NUMBER=1
          else
            # Get the highest RC number for this target version
            HIGHEST_RC=$(echo "$EXISTING_RCS" | tail -1)
            # Extract RC number (e.g., v1.2.3-rc4 -> 4)
            RC_NUMBER=$(echo "$HIGHEST_RC" | sed 's/.*-rc//')
            RC_NUMBER=$((RC_NUMBER + 1))
          fi
          
          RC_TAG="v${TARGET_VERSION}-rc${RC_NUMBER}"
          
          echo "new_version=$TARGET_VERSION" >> $GITHUB_OUTPUT
          echo "rc_tag=$RC_TAG" >> $GITHUB_OUTPUT
          echo "rc_number=$RC_NUMBER" >> $GITHUB_OUTPUT
          echo "highest_bump=$HIGHEST_BUMP" >> $GITHUB_OUTPUT
          
          echo "üèóÔ∏è Target version: $TARGET_VERSION (from baseline $LATEST_RELEASE, highest bump: $HIGHEST_BUMP)"
          echo "üî¢ RC tag: $RC_TAG (existing RCs for this version: $(echo "$EXISTING_RCS" | wc -l))"

      - name: Create RC Tag
        if: steps.conventional.outputs.should_release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "${{ steps.version.outputs.rc_tag }}" -m "Release Candidate ${{ steps.version.outputs.rc_tag }}"
          git push origin "${{ steps.version.outputs.rc_tag }}"
          
          echo "üöÄ Created RC tag: ${{ steps.version.outputs.rc_tag }}"

  # Runs on hotfix branch pushes
  create-hotfix-rc:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/hotfix/')
    name: Create Hotfix RC
    runs-on: ubuntu-latest
    outputs:
      hotfix_rc_tag: ${{ steps.hotfix_version.outputs.rc_tag }}
      should_create_hotfix_rc: ${{ steps.hotfix_version.outputs.should_release }}
      hotfix_version: ${{ steps.hotfix_version.outputs.new_version }}
      base_version: ${{ steps.hotfix_version.outputs.base_version }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate hotfix version
        id: hotfix_version
        run: |
          # Extract branch name and validate hotfix pattern
          BRANCH_NAME="${{ github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Validate hotfix branch format: hotfix/{issue}-{description}
          if [[ ! "$BRANCH_NAME" =~ ^hotfix/[0-9]+-.*$ ]]; then
            echo "‚ùå Invalid hotfix branch format: $BRANCH_NAME"
            echo "Expected: hotfix/{issue-number}-{description}"
            echo "Example: hotfix/123-fix-auth-bug"
            exit 1
          fi
          
          # Find the base version this hotfix branch was created from
          # Look for the most recent tag that this branch contains
          BASE_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          
          if [ -z "$BASE_TAG" ]; then
            echo "‚ùå No base tag found. Hotfix branches must be created from existing release tags"
            echo "Usage: git checkout v1.0.0 && git checkout -b hotfix/123-description"
            exit 1
          fi
          
          # Validate base tag is a release (not RC)
          if [[ "$BASE_TAG" == *"-rc"* ]]; then
            echo "‚ùå Hotfix base must be a release tag, not RC: $BASE_TAG"
            echo "Checkout a production release tag (e.g. v1.0.0) before creating hotfix branch"
            exit 1
          fi
          
          echo "base_version=$BASE_TAG" >> $GITHUB_OUTPUT
          
          # Calculate next patch version
          BASE_VERSION=${BASE_TAG#v}
          IFS='.' read -r -a VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]:-0}  
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Increment patch version
          PATCH=$((PATCH + 1))
          HOTFIX_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Find next RC number for this hotfix version
          EXISTING_HOTFIX_RCS=$(git tag -l "v${HOTFIX_VERSION}-rc*" | sort -V)
          if [ -z "$EXISTING_HOTFIX_RCS" ]; then
            RC_NUMBER=1
          else
            HIGHEST_RC=$(echo "$EXISTING_HOTFIX_RCS" | tail -1)
            RC_NUMBER=$(echo "$HIGHEST_RC" | sed 's/.*-rc//')
            RC_NUMBER=$((RC_NUMBER + 1))
          fi
          
          HOTFIX_RC_TAG="v${HOTFIX_VERSION}-rc${RC_NUMBER}"
          
          echo "new_version=$HOTFIX_VERSION" >> $GITHUB_OUTPUT
          echo "rc_tag=$HOTFIX_RC_TAG" >> $GITHUB_OUTPUT
          echo "rc_number=$RC_NUMBER" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT
          
          echo "ü©π Hotfix version: $HOTFIX_VERSION (from base $BASE_TAG)"
          echo "üî¢ Hotfix RC tag: $HOTFIX_RC_TAG"

      - name: Create Hotfix RC Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "${{ steps.hotfix_version.outputs.rc_tag }}" -m "Hotfix Release Candidate ${{ steps.hotfix_version.outputs.rc_tag }}"
          git push origin "${{ steps.hotfix_version.outputs.rc_tag }}"
          
          echo "üöÄ Created hotfix RC tag: ${{ steps.hotfix_version.outputs.rc_tag }}"

  # Build RC (beta) version for main branch
  build-rc:
    if: needs.create-rc.outputs.should_create_rc == 'true'
    name: Build RC (Beta)
    needs: create-rc
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: darwin
            goarch: amd64
          - goos: darwin  
            goarch: arm64
          - goos: windows
            goarch: amd64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-1.21-${{ hashFiles('**/go.sum') }}

      - name: Build RC Binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          mkdir -p dist
          EXT=""
          if [ "${{ matrix.goos }}" = "windows" ]; then
            EXT=".exe"
          fi
          
          BINARY_NAME="gh-issue-dependency-${{ needs.create-rc.outputs.rc_tag }}-${{ matrix.goos }}-${{ matrix.goarch }}${EXT}"
          
          go build \
            -ldflags "-s -w -X cmd.Version=${{ needs.create-rc.outputs.rc_tag }} -X cmd.Commit=${GITHUB_SHA:0:8} -X cmd.BuildType=beta" \
            -o "dist/${BINARY_NAME}" \
            .
          
          # Create checksums
          cd dist
          sha256sum "${BINARY_NAME}" > "${BINARY_NAME}.sha256"

      - name: Upload RC artifacts
        uses: actions/upload-artifact@v3
        with:
          name: rc-binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/

  # Build hotfix RC version  
  build-hotfix-rc:
    if: needs.create-hotfix-rc.outputs.should_create_hotfix_rc == 'true'
    name: Build Hotfix RC
    needs: create-hotfix-rc
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: darwin
            goarch: amd64
          - goos: darwin  
            goarch: arm64
          - goos: windows
            goarch: amd64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-1.21-${{ hashFiles('**/go.sum') }}

      - name: Build Hotfix RC Binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          mkdir -p dist
          EXT=""
          if [ "${{ matrix.goos }}" = "windows" ]; then
            EXT=".exe"
          fi
          
          BINARY_NAME="gh-issue-dependency-${{ needs.create-hotfix-rc.outputs.hotfix_rc_tag }}-${{ matrix.goos }}-${{ matrix.goarch }}${EXT}"
          
          go build \
            -ldflags "-s -w -X cmd.Version=${{ needs.create-hotfix-rc.outputs.hotfix_rc_tag }} -X cmd.Commit=${GITHUB_SHA:0:8} -X cmd.BuildType=hotfix" \
            -o "dist/${BINARY_NAME}" \
            .
          
          # Create checksums
          cd dist
          sha256sum "${BINARY_NAME}" > "${BINARY_NAME}.sha256"

      - name: Upload Hotfix RC artifacts
        uses: actions/upload-artifact@v3
        with:
          name: hotfix-rc-binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/

  # Manual gate using GitHub Environment
  promote-gate:
    if: |
      always() && (
        needs.create-rc.outputs.should_create_rc == 'true' || 
        needs.create-hotfix-rc.outputs.should_create_hotfix_rc == 'true' || 
        github.event_name == 'workflow_dispatch'
      )
    name: Release Approval Gate
    needs: [create-rc, build-rc, create-hotfix-rc, build-hotfix-rc]
    runs-on: ubuntu-latest
    environment: 
      name: release-approval
      url: https://github.com/${{ github.repository }}/releases
    
    steps:
      - name: Awaiting Release Approval
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "üöÄ Manual promotion requested for ${{ github.event.inputs.promote_rc_to_release }}"
            echo "üìã Promoting RC to production release..."
          elif [ "${{ needs.create-hotfix-rc.outputs.should_create_hotfix_rc }}" = "true" ]; then
            echo "ü©π Hotfix RC ${{ needs.create-hotfix-rc.outputs.hotfix_rc_tag }} built successfully"
            echo "üì¶ Base version: ${{ needs.create-hotfix-rc.outputs.base_version }}"
            echo "üèóÔ∏è Hotfix binaries available for testing"
            echo "‚è≥ Waiting for hotfix release approval..."
            echo ""
            echo "To test the hotfix RC build:"
            echo "1. Download hotfix artifacts from this workflow run"
            echo "2. Test the hotfix binaries against production scenarios"
            echo "3. If ready, approve this deployment to create production hotfix release"
          else
            echo "üìã RC ${{ needs.create-rc.outputs.rc_tag }} built successfully"
            echo "üèóÔ∏è Beta binaries available for testing"
            echo "‚è≥ Waiting for release approval..."
            echo ""
            echo "To test the RC build:"
            echo "1. Download artifacts from this workflow run"
            echo "2. Test the beta binaries"
            echo "3. If ready, approve this deployment to create production release"
          fi

  # Create release tag and build final release
  create-release:
    name: Create Release Build  
    needs: [create-rc, create-hotfix-rc, promote-gate]
    runs-on: ubuntu-latest
    if: always() && needs.promote-gate.result == 'success'
    outputs:
      release_tag: ${{ steps.release.outputs.release_tag }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release tag
        id: release
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RC_TAG="${{ github.event.inputs.promote_rc_to_release }}"
          elif [ "${{ needs.create-hotfix-rc.outputs.should_create_hotfix_rc }}" = "true" ]; then
            RC_TAG="${{ needs.create-hotfix-rc.outputs.hotfix_rc_tag }}"
          else
            RC_TAG="${{ needs.create-rc.outputs.rc_tag }}"
          fi
          
          # Convert RC tag to release tag (v1.2.0-rc1 -> v1.2.0)
          RELEASE_TAG=${RC_TAG%-rc*}
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "rc_tag=$RC_TAG" >> $GITHUB_OUTPUT
          
          if [ "${{ needs.create-hotfix-rc.outputs.should_create_hotfix_rc }}" = "true" ]; then
            echo "ü©π Creating hotfix release tag: $RELEASE_TAG (from RC: $RC_TAG)"
          else
            echo "üè∑Ô∏è Creating release tag: $RELEASE_TAG (from RC: $RC_TAG)"
          fi

      - name: Create Release Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the commit that the RC tag points to
          RC_COMMIT=$(git rev-list -n 1 "${{ steps.release.outputs.rc_tag }}")
          
          git tag -a "${{ steps.release.outputs.release_tag }}" $RC_COMMIT -m "Release ${{ steps.release.outputs.release_tag }}"
          git push origin "${{ steps.release.outputs.release_tag }}"
          
          echo "‚úÖ Created release tag: ${{ steps.release.outputs.release_tag }}"

  # This job will be triggered by the release tag created above
  notify-success:
    name: Notify Release Created
    needs: [create-release]
    runs-on: ubuntu-latest
    if: always() && needs.create-release.result == 'success'
    
    steps:
      - name: Success notification
        run: |
          echo "üéâ Release ${{ needs.create-release.outputs.release_tag }} has been created!"
          echo "üì¶ Production build will be triggered automatically by the release tag"
          echo "üîó Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.release_tag }}"