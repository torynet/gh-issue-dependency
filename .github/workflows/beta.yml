name: Beta

on:
  push:
    branches: 
      - main
      - 'hotfix/**'
  workflow_dispatch:
    inputs:
      force_rc:
        description: 'Force RC creation even if tests fail'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

jobs:
  test-and-validate:
    name: Test and Validate
    runs-on: ubuntu-latest
    outputs:
      should_create_rc: ${{ steps.conventional.outputs.should_release }}
      rc_tag: ${{ steps.version.outputs.rc_tag }}
      new_version: ${{ steps.version.outputs.new_version }}
      conventional_type: ${{ steps.conventional.outputs.conventional_type }}
      bump_type: ${{ steps.conventional.outputs.bump_type }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-1.21-${{ hashFiles('**/go.sum') }}

      - name: Run tests
        run: |
          echo "ğŸ§ª Running unit tests..."
          go test -v -race ./...

      - name: Run linting
        run: |
          echo "ğŸ” Running linting..."
          # Install golangci-lint if not available
          if ! command -v golangci-lint &> /dev/null; then
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
          fi
          golangci-lint run

      - name: Run integration tests
        run: |
          echo "ğŸ”„ Running integration tests..."
          if [ -f "./tests/integration_test.sh" ]; then
            chmod +x ./tests/integration_test.sh
            ./tests/integration_test.sh
          else
            echo "â„¹ï¸ No integration tests found"
          fi

      - name: Analyze conventional commit
        id: conventional
        run: |
          # Get commit subject (first line only) for conventional commit analysis
          COMMIT_SUBJECT="$(git log -1 --pretty=%s)"
          COMMIT_BODY="$(git log -1 --pretty=%B)"
          
          echo "commit_subject=$COMMIT_SUBJECT" >> $GITHUB_OUTPUT
          
          # Use heredoc for multiline commit message
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Check if this is a conventional commit that should trigger release
          SHOULD_RELEASE="false"
          BUMP_TYPE=""
          CONVENTIONAL_TYPE=""
          
          # Extract conventional commit type from new format: {issue}: {type}: {description}
          if [[ "$COMMIT_SUBJECT" =~ ^[0-9]+:\ (feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(!)?:\ .+ ]]; then
            # Extract the type (with potential ! for breaking change)
            CONVENTIONAL_TYPE=$(echo "$COMMIT_SUBJECT" | sed -E -n 's/^[0-9]+: ([a-z]+)(!)?: .*/\1\2/p')
            echo "ğŸ” Extracted conventional type from new format: $CONVENTIONAL_TYPE"
            
          # Check for standard conventional commit format: {type}: {description}
          elif [[ "$COMMIT_SUBJECT" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(!)?:\ .+ ]] || [[ "$COMMIT_SUBJECT" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(!)?(\(.+\))?:\ .+ ]]; then
            # Extract the type (with potential ! for breaking change)
            CONVENTIONAL_TYPE=$(echo "$COMMIT_SUBJECT" | sed -E -n 's/^([a-z]+)(!)?(\(.+\))?: .*/\1\2/p')
            echo "ğŸ” Extracted conventional type from standard format: $CONVENTIONAL_TYPE"
            
          # Legacy format without conventional commit type - no release
          else
            echo "â„¹ï¸ Commit does not follow conventional commit format for releases: $COMMIT_SUBJECT"
            echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Determine release type based on conventional commit type
          case "$CONVENTIONAL_TYPE" in
            *!)
              # Breaking change (any type with !)
              SHOULD_RELEASE="true"
              BUMP_TYPE="major"
              ;;
            feat)
              # New feature
              SHOULD_RELEASE="true"
              BUMP_TYPE="minor"
              ;;
            fix|perf)
              # Bug fix or performance improvement
              SHOULD_RELEASE="true"
              BUMP_TYPE="patch"
              ;;
            docs|style|refactor|test|chore|ci|build|revert)
              # Non-release types
              SHOULD_RELEASE="false"
              echo "â„¹ï¸ Commit type '$CONVENTIONAL_TYPE' does not trigger releases"
              ;;
            *)
              # Unknown type
              SHOULD_RELEASE="false"
              echo "âš ï¸ Unknown conventional commit type: $CONVENTIONAL_TYPE"
              ;;
          esac
          
          # Check for breaking changes in commit body
          if [[ "$COMMIT_BODY" == *"BREAKING CHANGE"* ]]; then
            SHOULD_RELEASE="true"
            BUMP_TYPE="major"
            echo "ğŸš¨ Breaking change detected in commit body"
          fi
          
          # Override if force_rc is set
          if [ "${{ github.event.inputs.force_rc }}" = "true" ]; then
            SHOULD_RELEASE="true"
            if [ -z "$BUMP_TYPE" ]; then
              BUMP_TYPE="patch"
            fi
            echo "ğŸš€ Force RC creation enabled"
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "conventional_type=$CONVENTIONAL_TYPE" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          
          if [ "$SHOULD_RELEASE" = "true" ]; then
            echo "âœ… Tests passed and conventional commit detected: $COMMIT_SUBJECT (type: $CONVENTIONAL_TYPE, bump: $BUMP_TYPE)"
          else
            echo "â„¹ï¸ Tests passed but commit does not trigger release: $COMMIT_SUBJECT (type: $CONVENTIONAL_TYPE)"
          fi

      - name: Calculate next version
        if: steps.conventional.outputs.should_release == 'true'
        id: version
        run: |
          # Get latest release tag (not RC tags) - this is our baseline
          LATEST_RELEASE=$(git tag -l "v*" | grep -v "rc" | sort -V | tail -1)
          if [ -z "$LATEST_RELEASE" ]; then
            LATEST_RELEASE="v0.0.0"
          fi
          echo "latest_release=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          
          # Parse baseline version numbers
          BASE_VERSION=${LATEST_RELEASE#v}
          IFS='.' read -r -a VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Calculate target version based on bump type
          BUMP_TYPE="${{ steps.conventional.outputs.bump_type }}"
          case "$BUMP_TYPE" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac
          
          TARGET_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Find next RC number for this target version
          EXISTING_RCS=$(git tag -l "v${TARGET_VERSION}-rc*" | sort -V)
          if [ -z "$EXISTING_RCS" ]; then
            RC_NUMBER=1
          else
            # Get the highest RC number for this target version
            HIGHEST_RC=$(echo "$EXISTING_RCS" | tail -1)
            # Extract RC number (e.g., v1.2.3-rc4 -> 4)
            RC_NUMBER=$(echo "$HIGHEST_RC" | sed 's/.*-rc//')
            RC_NUMBER=$((RC_NUMBER + 1))
          fi
          
          RC_TAG="v${TARGET_VERSION}-rc${RC_NUMBER}"
          
          echo "new_version=$TARGET_VERSION" >> $GITHUB_OUTPUT
          echo "rc_tag=$RC_TAG" >> $GITHUB_OUTPUT
          echo "rc_number=$RC_NUMBER" >> $GITHUB_OUTPUT
          
          echo "ğŸ—ï¸ Target version: $TARGET_VERSION (from baseline $LATEST_RELEASE, bump: $BUMP_TYPE)"
          echo "ğŸ”¢ RC tag: $RC_TAG"

  create-rc-tag:
    name: Create RC Tag
    needs: test-and-validate
    if: needs.test-and-validate.outputs.should_create_rc == 'true'
    runs-on: ubuntu-latest
    outputs:
      rc_tag: ${{ needs.test-and-validate.outputs.rc_tag }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create RC Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          RC_TAG="${{ needs.test-and-validate.outputs.rc_tag }}"
          
          git tag -a "$RC_TAG" -m "Release Candidate $RC_TAG"
          git push origin "$RC_TAG"
          
          echo "ğŸš€ Created RC tag: $RC_TAG"
          echo "ğŸ“‹ This will trigger the RC workflow to build artifacts and create pre-release"

  notify-completion:
    name: Notify Completion
    needs: [test-and-validate, create-rc-tag]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Notify Results
        run: |
          if [ "${{ needs.test-and-validate.result }}" = "failure" ]; then
            echo "âŒ Tests failed - no RC will be created"
            exit 1
          elif [ "${{ needs.test-and-validate.outputs.should_create_rc }}" = "true" ]; then
            if [ "${{ needs.create-rc-tag.result }}" = "success" ]; then
              echo "âœ… All tests passed and RC tag created: ${{ needs.test-and-validate.outputs.rc_tag }}"
              echo "ğŸ”„ RC workflow will now build artifacts and create pre-release"
            else
              echo "âŒ Tests passed but RC tag creation failed"
              exit 1
            fi
          else
            echo "âœ… All tests passed but commit does not trigger release"
            echo "â„¹ï¸ Type: ${{ needs.test-and-validate.outputs.conventional_type }}"
          fi

